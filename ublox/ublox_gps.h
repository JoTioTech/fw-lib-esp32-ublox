/* Copyright (c) 2019 James Jackson, Matt Rydalch, Havránek Kryštof
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef UBLOX_GPS_H
#define UBLOX_GPS_H

#include <cstdint>
#include <driver/uart.h>
#include <esp_log.h>
#include <esp_task_wdt.h>
#include <functional>
#include <iostream>
#include <esp_timer.h>
#include <sdkconfig.h>
#include <set>
#include <stdio.h>
#include <string>
#include <vector>

#define INPUT_REG_SIZE 128
#define HOLDING_REG_SIZE 128
#define SERIAL_BUFFER_SIZE 256
#define EX_UART_NUM (uart_port_t) CONFIG_GPS_UART_NUM

#define LENGTH_TO_COPY(x, y) (x + y >= BUFFER_SIZE ? BUFFER_SIZE - x : y)

#include "ublox_definitions.h"
// #include "serial_interface.h"
constexpr static char TAG[] = "OSCore";

namespace ublox {

class UbloxGPS {
	static constexpr int TIMEOUT_MS = 1000;
	constexpr static char TAG[] = "UbloxGPS";

	private:
	static void uartEvent(void* pvParameters);
	static QueueHandle_t uart0_queue;

	uint8_t prev_byte_;
	uint16_t buffer_head_ = 0;
	bool start_message_ = false;
	bool end_message_ = false;
	bool got_ack_ = false;
	bool got_ver_ = false;
	bool got_nack_ = false;
	parse_state_t parse_state_;
	uint8_t currMsgClass;
	uint8_t currMsgID;
	uint16_t currMsgLength;
	uint8_t checksumReferenceA;
	uint8_t internalUpdatePeriod = 200;
	uint8_t checksumReferenceB;
	uint32_t num_errors_ = 0;
	uint32_t num_messages_received_ = 0;
	uint8_t version; // 0 poll request, 1 poll (receiver to return config data key
									 // and value pairs)
	uint8_t layer;
	uint32_t cfgDataKey;
	uint64_t cfgData;
	uint8_t size;
	// uint8_t byte = 1;
	// uint8_t word = 2;
	// local storage
	volatile bool new_data_;

	int major_version_;
	int minor_version_;
	char module_name_[10];

	// Main buffers for communication
	UBX_message_t out_message_;
	UBX_message_t incomingMessage;

	/*
	 * @brief revert message parsing state to default
	 */
	void restart(); // DONE

	/**
	 * @brief configure the module with the given parameters
	 *
	 * @param version message version
	 * @param layer layer of configuration (RAM, BBR, FLASH, DEFAULT)
	 * @param cfgData configuration data to set
	 * @param cfgDataKey key for the configuration data
	 * @param size size of the configuration data (1 byte or 2 bytes)
	 */
	void configure(uint8_t version,
			uint8_t layer,
			uint64_t cfgData,
			uint32_t cfgDataKey,
			uint8_t size);

	/**
	 * @brief callback for version message
	 *
	 * This function is called when a version message is received.
	 */
	void versionCallback();

	public:

	UbloxGPS();


	// This function returns true when a new message has been parsed
	/**
	 * @brief processes each new byte read from the serial port
	 *
	 * @param byte the byte to process
	 * @return true if a byte was processed completely
	 */
	bool processNewByte(uint8_t byte); // DONE

	// low-level parsing functions
	/**
	 * @brief check if the message is valid, notify observers
	 *
	 * @return true if the message is valid
	 */
	bool decodeMessage();

	/**
	 * @brief calculate the checksum for a message
	 *
	 * @param msg_cls message class
	 * @param msg_id message type
	 * @param len length of the message
	 * @param payload the message payload
	 * @param checksumA checksum byte a
	 * @param checksumB checksum byte b
	 */
	uint16_t calculateChecksum(const uint8_t msg_cls, const uint8_t msg_id, const uint16_t len, const UBX_message_t payload);

  /**
	 * @brief configure serial connection to the module
	 */
	void setupSerial();


	/**
	 * @brief configure rate at which navigation solutions are generated by the receive
	 *
	 * the period also determines timing of all measurements/messages that depend on them.
	 *
	 * @param period_ms the period in milliseconds
	 */
	void setNavRate(uint16_t period_ms);

	void get_configuration(uint8_t version, uint8_t layer, uint32_t cfgDataKey);

	/**
	 * @brief set the dynamic mode of the module
	 * this affects settings of internal kalman filters that affect as data are processed
	 * on older divce WRIST and BIKE modes aren't available
	 *
	 * @param dynamicMode the dynamic mode to set
	 * @return true if the dynamic mode was set successfully
	 */
	bool setDynamicMode(uint8_t dynamicMode);


	/**
	 * @brief enable a message with the given class and id
	 * uses exclusively old protocol (version <= 23)
	 *
	 * @param msg_cls message class
	 * @param msg_id message id
	 * @param rate number of periods (configured with setNavRate) between messages
	 * @return true
	 */
	bool setMessageRate(uint8_t msg_cls, uint8_t msg_id, uint8_t rate);

	/**
	 * @brief enable a message with the given class and id
	 * uses new protocol (version > 23)
	 *
	 * @param msg_cls message class
	 * @param msg_id message id
	 * @param rate number of periods (configured with setNavRate) between messages
	 * @return true if device supports new protocol
	 */
	bool setMessageRate(uint32_t key_id, uint8_t rate);

	/*
	 * @brief disable NMEA messages switch to UBX
	 */
	void disableNMEA();

	void poll_value();



	void start_survey_in();

	/*
	 * @brief get the current version of the module
	 *
	 * this function will wait for a TIMEOUT_MS for a message to be received.
	 * if message doesn't arrive, it will return false. But version still might
	 * be set eventually when response arrives.
	 *
	 * @return true if the version was successfully retrieved
	 */
	bool requestVersion();

	bool wait_for_response();


	// listener handling
	// void registerListener(UBXListener* listener);
	//
	// std::vector<UBXListener*> listeners_;

	bool parsing_message();

	size_t num_messages_received();


	// Send the supplied message
	bool send_message(uint8_t msg_class, uint8_t msg_id, UBX_message_t& message, uint16_t len);




	void extract_version_string(const char* str);

	void extract_module_name(const char* str);

	// Parsing State Working Memory

	/*
	 * @brief get major device version
	 *
	 * @return major version
	 */
	int getMajorVersion() const { return major_version_; }

	/*
	 * @brief get minor device version
	 *
	 * @return minor version
	 */
	int getMinorVersion() const { return minor_version_; }


	/*
	 * @brief get module name
	 *
	 * @return module name
	 */
	const char* module_name() const { return module_name_; }

	// Serial Port
	// void write(const uint8_t byte);											// TODO replace
	//
	// void write(const uint8_t* byte, const size_t size); // TODO replace
};

} // namespace ublox
#endif // UBLOX_GPS_H
